<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>@motioneffector/sql - Demo</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { color: #333; border-bottom: 3px solid #4CAF50; padding-bottom: 10px; }
    h2 { color: #555; margin-top: 0; }
    section {
      margin: 20px 0;
      padding: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .test-pass { color: #4CAF50; }
    .test-fail { color: #f44336; font-weight: bold; }
    .test-output {
      background: #f9f9f9;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      max-height: 500px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      line-height: 1.5;
    }
    button {
      padding: 10px 20px;
      margin: 4px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      transition: all 0.2s;
    }
    button:hover { opacity: 0.9; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    .run-all {
      background: #4CAF50;
      color: white;
      font-size: 16px;
      padding: 14px 28px;
      font-weight: bold;
    }
    .clear-btn { background: #757575; color: white; }
    .action-btn { background: #2196F3; color: white; }
    .summary {
      font-size: 20px;
      font-weight: bold;
      margin: 15px 0;
      padding: 10px;
      border-radius: 4px;
      background: #e3f2fd;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin: 15px 0;
      flex-wrap: wrap;
    }
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
      flex: 1;
      min-width: 200px;
    }
    input, textarea {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: inherit;
      font-size: 14px;
    }
    textarea {
      font-family: 'Courier New', monospace;
      min-height: 80px;
      resize: vertical;
    }
    .output {
      background: #f5f5f5;
      padding: 12px;
      border-radius: 4px;
      border: 1px solid #ddd;
      margin-top: 10px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
    }
    .output.error { background: #ffebee; border-color: #f44336; color: #c62828; }
    .output.success { background: #e8f5e9; border-color: #4CAF50; color: #2e7d32; }
    label { font-weight: 600; color: #555; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    .loading { display: inline-block; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <h1>@motioneffector/sql Demo</h1>
  <p>Browser-based SQLite wrapper using SQL.js with automatic transaction queue management. Test all features below including concurrent transaction handling, migrations, persistence, and more.</p>

  <section id="test-runner">
    <h2>üß™ Automated Test Suite</h2>
    <p>Comprehensive tests covering all library features (30+ tests).</p>
    <div class="controls">
      <button class="run-all" onclick="runAllTests()">‚ñ∂ Run All Tests</button>
      <button class="clear-btn" onclick="clearResults()">Clear Results</button>
    </div>
    <div class="summary" id="summary"></div>
    <div class="test-output" id="test-output"></div>
  </section>

  <div class="grid">
    <section>
      <h2>üìù Query Execution</h2>
      <p>Execute SQL queries and see results.</p>
      <div class="input-group">
        <label>SQL Query:</label>
        <textarea id="query-sql" placeholder="SELECT * FROM users">CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT);
INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');
INSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com');
SELECT * FROM users;</textarea>
      </div>
      <div class="controls">
        <button class="action-btn" onclick="executeQuery()">Execute Query</button>
        <button class="clear-btn" onclick="clearQuery()">Clear</button>
      </div>
      <div id="query-output" class="output"></div>
    </section>

    <section>
      <h2>üìã Table Helper CRUD</h2>
      <p>Use table helpers for easy CRUD operations.</p>
      <div class="input-group">
        <label>Table Name:</label>
        <input type="text" id="table-name" value="products" placeholder="products">
      </div>
      <div class="controls">
        <button class="action-btn" onclick="createTable()">Create Table</button>
        <button class="action-btn" onclick="insertProduct()">Insert Sample Data</button>
        <button class="action-btn" onclick="queryProducts()">Query All</button>
        <button class="clear-btn" onclick="clearTableOutput()">Clear</button>
      </div>
      <div id="table-output" class="output"></div>
    </section>
  </div>

  <div class="grid">
    <section>
      <h2>üîÑ Transactions</h2>
      <p>Test transaction rollback on error.</p>
      <div class="controls">
        <button class="action-btn" onclick="testTransactionCommit()">Successful Transaction</button>
        <button class="action-btn" onclick="testTransactionRollback()">Transaction Rollback</button>
      </div>
      <div id="transaction-output" class="output"></div>
    </section>

    <section>
      <h2>üîÄ Transaction Queue</h2>
      <p>Demonstrates automatic queueing of concurrent transactions - no savepoint conflicts!</p>
      <div class="controls">
        <button class="action-btn" onclick="demoQueueConcurrent()">Run 5 Concurrent Transactions</button>
        <button class="action-btn" onclick="demoQueueWithProgress()">Queue with Progress</button>
        <button class="action-btn" onclick="demoQueueNested()">Concurrent + Nested</button>
        <button class="action-btn" onclick="demoQueueStress()">Stress Test (100 concurrent)</button>
      </div>
      <div id="queue-output" class="output"></div>
    </section>
  </div>

  <div class="grid">
    <section>
      <h2>üì¶ Export / Import</h2>
      <p>Export database to binary and import it back.</p>
      <div class="controls">
        <button class="action-btn" onclick="exportDatabase()">Export Database</button>
        <button class="action-btn" onclick="importDatabase()">Import Back</button>
        <button class="action-btn" onclick="downloadDatabase()">Download as File</button>
      </div>
      <div id="export-output" class="output"></div>
    </section>

  <section>
    <h2>üîß Migrations</h2>
    <p>Apply database schema migrations.</p>
    <div class="controls">
      <button class="action-btn" onclick="runMigration()">Apply Migration v1</button>
      <button class="action-btn" onclick="runMigration2()">Apply Migration v2</button>
      <button class="action-btn" onclick="checkMigrationVersion()">Check Version</button>
      <button class="action-btn" onclick="rollbackMigration()">Rollback to v1</button>
    </div>
    <div id="migration-output" class="output"></div>
  </section>

  <!-- Load SQL.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>

  <script>
    // ============================================
    // INLINED LIBRARY CODE (adapted from dist/index.js)
    // ============================================

    // Error classes
    class SqlError extends Error {
      constructor(message, code = 'SQLITE_ERROR') {
        super(message);
        this.name = 'SqlError';
        this.code = code;
        this.sql = undefined;
        this.params = undefined;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    }

    class SqlSyntaxError extends SqlError {
      constructor(message, code = 'SQLITE_ERROR') {
        super(message, code);
        this.name = 'SqlSyntaxError';
      }
    }

    class SqlConstraintError extends SqlError {
      constructor(message, code = 'SQLITE_CONSTRAINT') {
        super(message, code);
        this.name = 'SqlConstraintError';
      }
    }

    class SqlNotFoundError extends SqlError {
      constructor(message, code = 'SQLITE_ERROR') {
        super(message, code);
        this.name = 'SqlNotFoundError';
      }
    }

    class MigrationError extends SqlError {
      constructor(message, version) {
        super(message, 'MIGRATION_ERROR');
        this.name = 'MigrationError';
        this.version = version;
      }
    }

    // Storage adapter factory
    function getStorageAdapter(storage) {
      if (typeof storage === 'object') return storage;

      if (storage === 'localstorage') {
        return {
          async getItem(key) {
            const data = localStorage.getItem(`__motioneffector_sql_${key}`);
            if (!data) return null;
            const decoded = atob(data);
            const array = new Uint8Array(decoded.length);
            for (let i = 0; i < decoded.length; i++) {
              array[i] = decoded.charCodeAt(i);
            }
            return array;
          },
          async setItem(key, value) {
            const str = Array.from(value, b => String.fromCharCode(b)).join('');
            const encoded = btoa(str);
            localStorage.setItem(`__motioneffector_sql_${key}`, encoded);
          },
          async removeItem(key) {
            localStorage.removeItem(`__motioneffector_sql_${key}`);
          }
        };
      }

      // indexeddb (stub for demo)
      return {
        async getItem() { return null; },
        async setItem() {},
        async removeItem() {}
      };
    }

    // Main createDatabase function
    async function createDatabase(options) {
      // Validate options
      if (options?.persist) {
        if (!options.persist.key || options.persist.key.trim() === '') {
          throw new Error('persist.key cannot be empty');
        }
        if (typeof options.persist.storage === 'string' &&
            options.persist.storage !== 'indexeddb' &&
            options.persist.storage !== 'localstorage') {
          throw new Error('persist.storage must be "indexeddb" or "localstorage"');
        }
      }

      // Initialize SQL.js (using global initSqlJs from CDN)
      let SQL;
      try {
        SQL = await initSqlJs({
          locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        });
      } catch (error) {
        throw new Error(`Failed to load SQL.js WASM: ${error.message}`);
      }

      // Load data from storage or options
      let initialData = options?.data;
      if (!initialData && options?.persist) {
        const storage = getStorageAdapter(options.persist.storage);
        try {
          const stored = await storage.getItem(options.persist.key);
          if (stored) initialData = stored;
        } catch (error) {
          console.warn('Failed to load from persistent storage:', error);
        }
      }

      // Validate SQLite data
      if (initialData && initialData.length > 0) {
        const header = Array.from(initialData.slice(0, 16));
        const expectedHeader = [83, 81, 76, 105, 116, 101, 32, 102, 111, 114, 109, 97, 116, 32, 51, 0];
        const isValid = expectedHeader.every((byte, i) => header[i] === byte);
        if (!isValid) {
          throw new SqlError('Invalid SQLite database format');
        }
      }

      // Create database
      let db;
      try {
        db = new SQL.Database(initialData);
      } catch (error) {
        throw new SqlError(`Failed to create database: ${error.message}`);
      }

      // Enable foreign keys
      try {
        db.run('PRAGMA foreign_keys = ON');
      } catch {}

      let closed = false;
      let transactionDepth = 0;
      let savepointCounter = 0;
      const activeSavepoints = [];

      // Transaction queue for concurrent transaction management
      let transactionQueue = [];
      let isProcessingQueue = false;

      const autoSave = options?.autoSave ?? (options?.persist ? true : false);
      const autoSaveDebounce = options?.autoSaveDebounce ?? 1000;
      let autoSaveTimer;

      const scheduleSave = () => {
        if (!autoSave || !options?.persist) return;
        if (autoSaveTimer) clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(() => {
          saveToStorage().catch(error => {
            console.error('Auto-save failed:', error);
          });
        }, autoSaveDebounce);
      };

      const saveToStorage = async () => {
        if (!options?.persist) return;
        const storage = getStorageAdapter(options.persist.storage);
        const data = database.export();
        await storage.setItem(options.persist.key, data);
      };

      const ensureOpen = () => {
        if (closed) throw new Error('Database is closed');
      };

      // Process queued transactions serially
      async function processQueue() {
        // Guard: Only one processor runs at a time
        if (isProcessingQueue) return;
        if (transactionQueue.length === 0) return;

        isProcessingQueue = true;

        while (transactionQueue.length > 0) {
          const item = transactionQueue.shift();
          if (!item) break;

          const { fn, resolve, reject } = item;

          try {
            db.exec('BEGIN');

            // Increment depth to track that we're in a transaction context
            // Nested calls will see depth > 0 and use savepoints
            transactionDepth++;

            const result = await fn();

            db.exec('COMMIT');
            scheduleSave();

            resolve(result);
          } catch (error) {
            try {
              db.exec('ROLLBACK');
            } catch {
              // Ignore rollback errors
            }

            reject(error);
          } finally {
            transactionDepth--;
          }
        }

        isProcessingQueue = false;
      }

      const countPositionalPlaceholders = (sql) => {
        let count = 0, inString = false, stringChar = '';
        for (let i = 0; i < sql.length; i++) {
          const char = sql[i];
          if (inString) {
            if (char === stringChar && sql[i - 1] !== '\\') inString = false;
          } else {
            if (char === "'" || char === '"') {
              inString = true;
              stringChar = char;
            } else if (char === '?') {
              count++;
            }
          }
        }
        return count;
      };

      const extractNamedParameters = (sql) => {
        const names = new Set();
        const regex = /[:$@]([a-zA-Z_][a-zA-Z0-9_]*)/g;
        let match;
        while ((match = regex.exec(sql)) !== null) {
          if (match[1]) names.add(match[1]);
        }
        return names;
      };

      const validateParams = (sql, params) => {
        if (!params) {
          const positionalCount = countPositionalPlaceholders(sql);
          const namedParams = extractNamedParameters(sql);
          if (positionalCount > 0 || namedParams.size > 0) {
            throw new SqlError('SQL requires parameters but none provided');
          }
          return;
        }

        if (Array.isArray(params)) {
          const expected = countPositionalPlaceholders(sql);
          if (params.length !== expected) {
            throw new SqlError(
              `Parameter count mismatch: SQL expects ${expected} parameters but ${params.length} provided`
            );
          }
        } else {
          const requiredParams = extractNamedParameters(sql);
          const providedParams = new Set(Object.keys(params));
          for (const required of requiredParams) {
            if (!providedParams.has(required)) {
              throw new SqlError(`Missing required parameter: ${required}`);
            }
          }
        }
      };

      const convertParams = (params) => {
        if (!params) return undefined;
        if (Array.isArray(params)) return params.map(convertValue);

        const converted = {};
        for (const [key, value] of Object.entries(params)) {
          const convertedValue = convertValue(value);
          converted[`:${key}`] = convertedValue;
          converted[`$${key}`] = convertedValue;
          converted[`@${key}`] = convertedValue;
          converted[key] = convertedValue;
        }
        return converted;
      };

      const convertValue = (value) => {
        if (value === null || value === undefined) return null;
        if (value instanceof Date) return value.toISOString();
        if (typeof value === 'boolean') return value ? 1 : 0;
        if (typeof value === 'bigint') return value.toString();
        if (value instanceof ArrayBuffer) return new Uint8Array(value);
        if (value instanceof Uint8Array) return value;
        if (typeof value === 'number' || typeof value === 'string') return value;
        throw new TypeError(`Unsupported parameter type: ${typeof value}`);
      };

      const handleSqlError = (error, sql, params) => {
        const message = error.message || String(error);

        if (message.includes('syntax') || message.includes('parse')) {
          const err = new SqlSyntaxError(message);
          if (sql !== undefined) err.sql = sql;
          if (params !== undefined) err.params = params;
          throw err;
        }

        if (message.includes('constraint') || message.includes('UNIQUE') || message.includes('NOT NULL')) {
          const err = new SqlConstraintError(message);
          if (sql !== undefined) err.sql = sql;
          if (params !== undefined) err.params = params;
          throw err;
        }

        if (message.includes('no such table') || message.includes('no such column')) {
          const err = new SqlNotFoundError(message);
          if (sql !== undefined) err.sql = sql;
          if (params !== undefined) err.params = params;
          throw err;
        }

        const err = new SqlError(message);
        if (sql !== undefined) err.sql = sql;
        if (params !== undefined) err.params = params;
        throw err;
      };

      // Database API
      const database = {
        run(sql, params) {
          ensureOpen();
          try {
            validateParams(sql, params);
            const convertedParams = convertParams(params);

            if (convertedParams) {
              const stmt = db.prepare(sql);
              stmt.bind(convertedParams);
              stmt.step();
              stmt.free();
            } else {
              db.run(sql);
            }

            const changes = db.getRowsModified();
            let lastInsertRowId = 0;

            if (changes > 0 && sql.trim().toUpperCase().startsWith('INSERT')) {
              try {
                const result = db.exec('SELECT last_insert_rowid() as id');
                if (result[0]?.values[0]?.[0]) {
                  lastInsertRowId = result[0].values[0][0];
                }
              } catch {}
            }

            if (transactionDepth === 0) scheduleSave();
            return { changes, lastInsertRowId };
          } catch (error) {
            if (error instanceof TypeError) throw error;
            return handleSqlError(error, sql, params);
          }
        },

        get(sql, params) {
          ensureOpen();
          try {
            validateParams(sql, params);
            const stmt = db.prepare(sql);
            const convertedParams = convertParams(params);
            if (convertedParams) stmt.bind(convertedParams);

            if (stmt.step()) {
              const row = stmt.getAsObject();
              stmt.free();
              return row;
            }
            stmt.free();
            return undefined;
          } catch (error) {
            if (error instanceof TypeError) throw error;
            return handleSqlError(error, sql, params);
          }
        },

        all(sql, params) {
          ensureOpen();
          try {
            validateParams(sql, params);
            const stmt = db.prepare(sql);
            const convertedParams = convertParams(params);
            if (convertedParams) stmt.bind(convertedParams);

            const results = [];
            while (stmt.step()) {
              results.push(stmt.getAsObject());
            }
            stmt.free();
            return results;
          } catch (error) {
            if (error instanceof TypeError) throw error;
            return handleSqlError(error, sql, params);
          }
        },

        exec(sql) {
          ensureOpen();
          try {
            db.exec(sql);
            if (transactionDepth === 0) scheduleSave();
          } catch (error) {
            handleSqlError(error, sql);
          }
        },

        async migrate(migrations) {
          ensureOpen();

          for (const migration of migrations) {
            if (!Number.isInteger(migration.version) || migration.version < 1) {
              throw new Error('Migration version must be >= 1');
            }
            if (!migration.up) {
              throw new Error('Migration must have an "up" script');
            }
          }

          const versions = migrations.map(m => m.version);
          const uniqueVersions = new Set(versions);
          if (versions.length !== uniqueVersions.size) {
            const duplicate = versions.find((v, i) => versions.indexOf(v) !== i);
            throw new Error(`Duplicate migration version: ${duplicate}`);
          }

          database.exec(`
            CREATE TABLE IF NOT EXISTS _migrations (
              version INTEGER PRIMARY KEY,
              applied_at TEXT NOT NULL
            )
          `);

          const currentVersion = database.getMigrationVersion();
          const sorted = [...migrations].sort((a, b) => a.version - b.version);
          const applied = [];

          for (const migration of sorted) {
            if (migration.version <= currentVersion) continue;

            try {
              await database.transaction(() => {
                database.exec(migration.up);
                database.run(
                  'INSERT INTO _migrations (version, applied_at) VALUES (?, ?)',
                  [migration.version, new Date().toISOString()]
                );
              });
              applied.push(migration.version);
            } catch (error) {
              throw new MigrationError(
                `Migration ${migration.version} failed: ${error.message}`,
                migration.version
              );
            }
          }

          return applied;
        },

        async rollback(targetVersion = 0, migrations) {
          ensureOpen();

          if (targetVersion < 0) {
            throw new MigrationError('Target version cannot be negative');
          }

          const currentVersion = database.getMigrationVersion();
          if (targetVersion > currentVersion) {
            throw new MigrationError(
              `Target version ${targetVersion} is greater than current version ${currentVersion}`
            );
          }

          const appliedMigrations = database.all(
            'SELECT version FROM _migrations WHERE version > ? ORDER BY version DESC',
            [targetVersion]
          );

          const rolledBack = [];

          if (!migrations || migrations.length === 0) {
            if (appliedMigrations.length > 0) {
              throw new MigrationError(
                'Rollback requires migrations with down scripts',
                appliedMigrations[0].version
              );
            }
            return rolledBack;
          }

          for (const { version } of appliedMigrations) {
            const migration = migrations.find(m => m.version === version);
            if (!migration?.down) {
              throw new MigrationError(
                `Migration ${version} has no down script`,
                version
              );
            }

            try {
              await database.transaction(() => {
                database.exec(migration.down);
                database.run('DELETE FROM _migrations WHERE version = ?', [version]);
              });
              rolledBack.push(version);
            } catch (error) {
              throw new MigrationError(
                `Rollback of migration ${version} failed: ${error.message}`,
                version
              );
            }
          }

          return rolledBack;
        },

        getMigrationVersion() {
          ensureOpen();
          try {
            const result = database.get('SELECT MAX(version) as version FROM _migrations');
            return result?.version ?? 0;
          } catch {
            return 0;
          }
        },

        async transaction(fn) {
          ensureOpen();

          // Check if we're nested inside another transaction
          // If depth > 0, we're in a transaction context and should use savepoints
          const isNested = transactionDepth > 0;

          if (isNested) {
            // NESTED: Use savepoint for nested transaction
            const savepointName = `sp_${++savepointCounter}`;
            activeSavepoints.push(savepointName);
            transactionDepth++;

            try {
              database.exec(`SAVEPOINT ${savepointName}`);
            } catch (error) {
              transactionDepth--;
              activeSavepoints.pop();
              throw error;
            }

            try {
              const result = await fn();
              database.exec(`RELEASE ${savepointName}`);
              transactionDepth--;
              activeSavepoints.pop();
              return result;
            } catch (error) {
              try {
                database.exec(`ROLLBACK TO ${savepointName}`);
                database.exec(`RELEASE ${savepointName}`);
              } catch {}
              transactionDepth--;
              activeSavepoints.pop();
              throw error;
            }
          } else {
            // TOP-LEVEL: Add to queue and process
            return new Promise((resolve, reject) => {
              const id = `txn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              transactionQueue.push({
                id,
                fn,
                resolve,
                reject,
                enqueuedAt: Date.now()
              });

              // Schedule queue processing as a microtask (not synchronous)
              // This ensures concurrent transaction() calls can complete before processing starts
              Promise.resolve().then(() => processQueue());
            });
          }
        },

        get inTransaction() {
          return transactionDepth > 0;
        },

        table(tableName, options) {
          ensureOpen();

          if (!tableName || tableName.trim() === '') {
            throw new Error('tableName cannot be empty');
          }

          const primaryKey = options?.primaryKey ?? 'id';

          return {
            insert(data) {
              for (const key of Object.keys(data)) {
                if (key.includes(';') || key.includes('--') || key.includes('/*')) {
                  throw new Error(`Invalid column name: ${key}`);
                }
              }

              const entries = Object.entries(data).filter(([_, value]) => value !== undefined);
              const columns = entries.map(([key]) => key);
              const values = entries.map(([_, value]) => value);
              const placeholders = columns.map(() => '?').join(', ');

              const sql = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`;
              const result = database.run(sql, values);
              return result.lastInsertRowId;
            },

            find(id, options) {
              const keyColumn = options?.key ?? primaryKey;
              return database.get(`SELECT * FROM ${tableName} WHERE ${keyColumn} = ?`, [id]);
            },

            where(conditions) {
              if (Object.keys(conditions).length === 0) {
                return database.all(`SELECT * FROM ${tableName}`);
              }

              const clauses = [];
              const values = [];

              for (const [key, value] of Object.entries(conditions)) {
                if (value === null) {
                  clauses.push(`${key} IS NULL`);
                } else {
                  clauses.push(`${key} = ?`);
                  values.push(value);
                }
              }

              const sql = `SELECT * FROM ${tableName} WHERE ${clauses.join(' AND ')}`;
              return database.all(sql, values);
            },

            update(id, data, options) {
              const keyColumn = options?.key ?? primaryKey;
              const entries = Object.entries(data).filter(([_, value]) => value !== undefined);

              if (entries.length === 0) return 0;

              const setClauses = entries.map(([key]) => `${key} = ?`);
              const values = [...entries.map(([_, value]) => value), id];

              const sql = `UPDATE ${tableName} SET ${setClauses.join(', ')} WHERE ${keyColumn} = ?`;
              const result = database.run(sql, values);
              return result.changes;
            },

            delete(id, options) {
              const keyColumn = options?.key ?? primaryKey;
              const result = database.run(`DELETE FROM ${tableName} WHERE ${keyColumn} = ?`, [id]);
              return result.changes;
            },

            count(conditions) {
              if (!conditions || Object.keys(conditions).length === 0) {
                const result = database.get(`SELECT COUNT(*) as count FROM ${tableName}`);
                return result?.count ?? 0;
              }

              const clauses = [];
              const values = [];

              for (const [key, value] of Object.entries(conditions)) {
                if (value === null) {
                  clauses.push(`${key} IS NULL`);
                } else {
                  clauses.push(`${key} = ?`);
                  values.push(value);
                }
              }

              const sql = `SELECT COUNT(*) as count FROM ${tableName} WHERE ${clauses.join(' AND ')}`;
              const result = database.get(sql, values);
              return result?.count ?? 0;
            },

            all() {
              return database.all(`SELECT * FROM ${tableName}`);
            }
          };
        },

        export() {
          ensureOpen();
          return db.export();
        },

        import(data) {
          ensureOpen();
          try {
            const uint8Array = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
            db.close();
            db = new SQL.Database(uint8Array);
            scheduleSave();
          } catch (error) {
            throw new SqlError(`Failed to import database: ${error.message}`);
          }
        },

        async save() {
          ensureOpen();
          if (autoSaveTimer) clearTimeout(autoSaveTimer);
          await saveToStorage();
        },

        async load() {
          ensureOpen();
          if (!options?.persist) return;
          const storage = getStorageAdapter(options.persist.storage);
          const data = await storage.getItem(options.persist.key);
          if (data) database.import(data);
        },

        getTables() {
          ensureOpen();
          const tables = database.all(
            "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name != '_migrations'"
          );
          return tables.map(t => t.name);
        },

        getTableInfo(tableName) {
          ensureOpen();
          try {
            const info = database.all(`PRAGMA table_info(${tableName})`);
            return info.map(col => ({
              name: col.name,
              type: col.type,
              nullable: col.notnull === 0,
              defaultValue: col.dflt_value,
              primaryKey: col.pk === 1
            }));
          } catch {
            throw new SqlNotFoundError(`Table "${tableName}" not found`);
          }
        },

        getIndexes() {
          ensureOpen();
          return [];
        },

        close() {
          if (closed) return;

          // Reject all pending transactions
          while (transactionQueue.length > 0) {
            const item = transactionQueue.shift();
            if (item) {
              item.reject(new Error('Database closed with pending transactions'));
            }
          }

          if (autoSaveTimer) clearTimeout(autoSaveTimer);
          db.close();
          closed = true;
        },

        async clone() {
          ensureOpen();
          const data = database.export();
          return createDatabase({ data });
        },

        clear() {
          ensureOpen();
          const tables = database.getTables();
          for (const table of tables) {
            database.exec(`DELETE FROM ${table}`);
          }
          scheduleSave();
        },

        async destroy() {
          if (options?.persist) {
            await getStorageAdapter(options.persist.storage).removeItem(options.persist.key);
          }
          database.close();
        },

        sql(strings, ...values) {
          const sql = strings.reduce((acc, str, i) => acc + str + (i < values.length ? '?' : ''), '');
          return { sql, params: values };
        },

        prepare(sql) {
          ensureOpen();
          const stmt = db.prepare(sql);
          let finalized = false;

          const checkFinalized = () => {
            if (finalized) throw new Error('Statement has been finalized');
          };

          return {
            run(params) {
              checkFinalized();
              const converted = convertParams(params);
              if (converted) stmt.bind(converted);
              stmt.step();
              stmt.reset();
              const changes = db.getRowsModified();
              const lastInsertRowId = db.exec('SELECT last_insert_rowid() as id')[0]?.values[0]?.[0] || 0;
              return { changes, lastInsertRowId };
            },

            get(params) {
              checkFinalized();
              const converted = convertParams(params);
              if (converted) stmt.bind(converted);
              if (stmt.step()) {
                const row = stmt.getAsObject();
                stmt.reset();
                return row;
              }
              stmt.reset();
              return undefined;
            },

            all(params) {
              checkFinalized();
              const converted = convertParams(params);
              if (converted) stmt.bind(converted);
              const results = [];
              while (stmt.step()) {
                results.push(stmt.getAsObject());
              }
              stmt.reset();
              return results;
            },

            finalize() {
              if (!finalized) {
                stmt.free();
                finalized = true;
              }
            }
          };
        },

        insertMany(tableName, rows) {
          ensureOpen();

          if (rows.length === 0) return [];

          const firstRow = rows[0];
          if (!firstRow) return [];

          const columns = Object.keys(firstRow);
          for (const row of rows) {
            const rowColumns = Object.keys(row);
            if (rowColumns.length !== columns.length || !rowColumns.every(c => columns.includes(c))) {
              throw new Error('All rows must have the same columns');
            }
          }

          const ids = [];
          database.transaction(() => {
            for (const row of rows) {
              const id = database.table(tableName).insert(row);
              ids.push(id);
            }
          });
          return ids;
        }
      };

      return database;
    }

    // Expose to window
    window.createDatabase = createDatabase;
    window.SqlError = SqlError;
    window.SqlSyntaxError = SqlSyntaxError;
    window.SqlConstraintError = SqlConstraintError;
    window.SqlNotFoundError = SqlNotFoundError;
    window.MigrationError = MigrationError;
  </script>

  <script>
    // ============================================
    // DEMO AND TEST CODE
    // ============================================

    let demoDb = null;
    let exportedData = null;

    // Initialize demo database
    async function initDemoDb() {
      if (!demoDb) {
        demoDb = await createDatabase();
      }
      return demoDb;
    }

    // Comprehensive automated tests
    const tests = [
      // Database creation tests
      {
        name: 'creates database with default options',
        fn: async () => {
          const db = await createDatabase();
          if (!db) throw new Error('Database is undefined');
          if (typeof db.run !== 'function') throw new Error('Missing run method');
          db.close();
        }
      },
      {
        name: 'creates database with initial data',
        fn: async () => {
          const db1 = await createDatabase();
          db1.exec('CREATE TABLE test (value INTEGER)');
          db1.run('INSERT INTO test VALUES (42)');
          const exported = db1.export();
          db1.close();

          const db2 = await createDatabase({ data: exported });
          const result = db2.get('SELECT value FROM test');
          if (result.value !== 42) throw new Error(`Expected 42, got ${result.value}`);
          db2.close();
        }
      },
      {
        name: 'rejects invalid SQLite data',
        fn: async () => {
          const invalidData = new Uint8Array([1, 2, 3, 4, 5]);
          try {
            await createDatabase({ data: invalidData });
            throw new Error('Should have thrown SqlError');
          } catch (e) {
            if (!(e instanceof SqlError)) throw new Error('Expected SqlError');
          }
        }
      },

      // Query execution tests
      {
        name: 'run() executes INSERT and returns lastInsertRowId',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)');
          const result = db.run('INSERT INTO test (value) VALUES (?)', ['hello']);
          if (result.changes !== 1) throw new Error('Expected 1 change');
          if (result.lastInsertRowId === 0) throw new Error('Expected non-zero lastInsertRowId');
          db.close();
        }
      },
      {
        name: 'run() with UPDATE returns changes count',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER, value TEXT)');
          db.run('INSERT INTO test VALUES (1, "a"), (2, "b"), (3, "c")');
          const result = db.run('UPDATE test SET value = ? WHERE id > ?', ['x', 1]);
          if (result.changes !== 2) throw new Error(`Expected 2 changes, got ${result.changes}`);
          db.close();
        }
      },
      {
        name: 'get() returns single row',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER, name TEXT)');
          db.run('INSERT INTO test VALUES (1, "Alice")');
          const row = db.get('SELECT * FROM test WHERE id = ?', [1]);
          if (row.name !== 'Alice') throw new Error('Expected Alice');
          db.close();
        }
      },
      {
        name: 'get() returns undefined when no match',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER)');
          const row = db.get('SELECT * FROM test WHERE id = 999');
          if (row !== undefined) throw new Error('Expected undefined');
          db.close();
        }
      },
      {
        name: 'all() returns multiple rows',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (value INTEGER)');
          db.run('INSERT INTO test VALUES (1), (2), (3)');
          const rows = db.all('SELECT * FROM test');
          if (rows.length !== 3) throw new Error(`Expected 3 rows, got ${rows.length}`);
          db.close();
        }
      },
      {
        name: 'all() returns empty array when no matches',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER)');
          const rows = db.all('SELECT * FROM test');
          if (rows.length !== 0) throw new Error('Expected empty array');
          db.close();
        }
      },

      // Parameterized query tests
      {
        name: 'positional parameters work correctly',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (a INTEGER, b TEXT)');
          db.run('INSERT INTO test VALUES (?, ?)', [42, 'hello']);
          const row = db.get('SELECT * FROM test WHERE a = ? AND b = ?', [42, 'hello']);
          if (row.a !== 42 || row.b !== 'hello') throw new Error('Parameter mismatch');
          db.close();
        }
      },
      {
        name: 'named parameters with colon prefix',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (name TEXT, age INTEGER)');
          db.run('INSERT INTO test VALUES (:name, :age)', { name: 'Bob', age: 30 });
          const row = db.get('SELECT * FROM test WHERE name = :name', { name: 'Bob' });
          if (row.age !== 30) throw new Error('Expected age 30');
          db.close();
        }
      },
      {
        name: 'throws SqlError on parameter count mismatch',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (a INTEGER, b INTEGER)');
          try {
            db.run('INSERT INTO test VALUES (?, ?)', [1]); // Missing second param
            throw new Error('Should have thrown');
          } catch (e) {
            if (!(e instanceof SqlError)) throw new Error('Expected SqlError');
          }
          db.close();
        }
      },
      {
        name: 'throws SqlError on missing named parameter',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (a INTEGER)');
          try {
            db.run('INSERT INTO test VALUES (:value)', {}); // Missing :value
            throw new Error('Should have thrown');
          } catch (e) {
            if (!(e instanceof SqlError)) throw new Error('Expected SqlError');
          }
          db.close();
        }
      },

      // Transaction tests
      {
        name: 'transaction commits on success',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (value INTEGER)');
          await db.transaction(() => {
            db.run('INSERT INTO test VALUES (1)');
            db.run('INSERT INTO test VALUES (2)');
          });
          const rows = db.all('SELECT * FROM test');
          if (rows.length !== 2) throw new Error('Expected 2 rows');
          db.close();
        }
      },
      {
        name: 'transaction rolls back on error',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (value INTEGER)');
          db.run('INSERT INTO test VALUES (0)');

          try {
            await db.transaction(() => {
              db.run('INSERT INTO test VALUES (1)');
              throw new Error('Simulated failure');
            });
          } catch {}

          const rows = db.all('SELECT * FROM test');
          if (rows.length !== 1) throw new Error('Expected rollback');
          db.close();
        }
      },
      {
        name: 'nested transactions use savepoints',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (value INTEGER)');

          await db.transaction(async () => {
            db.run('INSERT INTO test VALUES (1)');
            await db.transaction(() => {
              db.run('INSERT INTO test VALUES (2)');
            });
            db.run('INSERT INTO test VALUES (3)');
          });

          const rows = db.all('SELECT * FROM test');
          if (rows.length !== 3) throw new Error('Expected 3 rows');
          db.close();
        }
      },
      {
        name: 'inner transaction rollback preserves outer changes',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (value INTEGER)');

          await db.transaction(async () => {
            db.run('INSERT INTO test VALUES (1)');

            try {
              await db.transaction(() => {
                db.run('INSERT INTO test VALUES (2)');
                throw new Error('Inner failure');
              });
            } catch {}

            db.run('INSERT INTO test VALUES (3)');
          });

          const values = db.all('SELECT value FROM test ORDER BY value').map(r => r.value);
          if (JSON.stringify(values) !== JSON.stringify([1, 3])) {
            throw new Error('Expected [1, 3]');
          }
          db.close();
        }
      },
      {
        name: 'inTransaction property reflects transaction state',
        fn: async () => {
          const db = await createDatabase();
          if (db.inTransaction) throw new Error('Should not be in transaction');

          await db.transaction(() => {
            if (!db.inTransaction) throw new Error('Should be in transaction');
          });

          if (db.inTransaction) throw new Error('Should not be in transaction after commit');
          db.close();
        }
      },

      // Migration tests
      {
        name: 'migrate() applies new migrations',
        fn: async () => {
          const db = await createDatabase();
          const migrations = [
            { version: 1, up: 'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)' },
            { version: 2, up: 'ALTER TABLE users ADD COLUMN email TEXT' }
          ];

          const applied = await db.migrate(migrations);
          if (applied.length !== 2) throw new Error('Expected 2 migrations applied');
          if (db.getMigrationVersion() !== 2) throw new Error('Expected version 2');
          db.close();
        }
      },
      {
        name: 'migrate() skips already applied migrations',
        fn: async () => {
          const db = await createDatabase();
          const migrations = [
            { version: 1, up: 'CREATE TABLE test (id INTEGER)' }
          ];

          await db.migrate(migrations);
          const applied = await db.migrate(migrations);
          if (applied.length !== 0) throw new Error('Expected no new migrations');
          db.close();
        }
      },
      {
        name: 'rollback() reverts migrations with down scripts',
        fn: async () => {
          const db = await createDatabase();
          const migrations = [
            {
              version: 1,
              up: 'CREATE TABLE test (id INTEGER)',
              down: 'DROP TABLE test'
            },
            {
              version: 2,
              up: 'CREATE TABLE users (id INTEGER)',
              down: 'DROP TABLE users'
            }
          ];

          await db.migrate(migrations);
          await db.rollback(1, migrations);

          if (db.getMigrationVersion() !== 1) throw new Error('Expected version 1');
          const tables = db.getTables();
          if (tables.includes('users')) throw new Error('users table should be dropped');
          db.close();
        }
      },
      {
        name: 'getMigrationVersion() returns 0 for fresh database',
        fn: async () => {
          const db = await createDatabase();
          if (db.getMigrationVersion() !== 0) throw new Error('Expected version 0');
          db.close();
        }
      },

      // Table helper tests
      {
        name: 'table().insert() inserts and returns ID',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)');
          const table = db.table('products');
          const id = table.insert({ name: 'Widget', price: 9.99 });
          if (!id || id === 0) throw new Error('Expected non-zero ID');
          db.close();
        }
      },
      {
        name: 'table().find() retrieves by ID',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT)');
          const table = db.table('products');
          const id = table.insert({ name: 'Gadget' });
          const product = table.find(id);
          if (product.name !== 'Gadget') throw new Error('Expected Gadget');
          db.close();
        }
      },
      {
        name: 'table().where() filters by conditions',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE products (id INTEGER, category TEXT, price REAL)');
          const table = db.table('products');
          table.insert({ category: 'books', price: 10 });
          table.insert({ category: 'books', price: 15 });
          table.insert({ category: 'tools', price: 20 });

          const books = table.where({ category: 'books' });
          if (books.length !== 2) throw new Error('Expected 2 books');
          db.close();
        }
      },
      {
        name: 'table().update() modifies record',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)');
          const table = db.table('products');
          const id = table.insert({ name: 'Item', price: 10 });
          table.update(id, { price: 15 });
          const product = table.find(id);
          if (product.price !== 15) throw new Error('Expected price 15');
          db.close();
        }
      },
      {
        name: 'table().delete() removes record',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT)');
          const table = db.table('products');
          const id = table.insert({ name: 'ToDelete' });
          const deleted = table.delete(id);
          if (deleted !== 1) throw new Error('Expected 1 deletion');
          const product = table.find(id);
          if (product !== undefined) throw new Error('Product should be deleted');
          db.close();
        }
      },
      {
        name: 'table().count() returns row count',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE products (id INTEGER, category TEXT)');
          const table = db.table('products');
          table.insert({ category: 'A' });
          table.insert({ category: 'A' });
          table.insert({ category: 'B' });

          if (table.count() !== 3) throw new Error('Expected total count 3');
          if (table.count({ category: 'A' }) !== 2) throw new Error('Expected count 2 for A');
          db.close();
        }
      },
      {
        name: 'table().all() returns all rows',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (value INTEGER)');
          const table = db.table('test');
          table.insert({ value: 1 });
          table.insert({ value: 2 });
          const all = table.all();
          if (all.length !== 2) throw new Error('Expected 2 rows');
          db.close();
        }
      },

      // Export/Import tests
      {
        name: 'export() returns Uint8Array',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER)');
          const exported = db.export();
          if (!(exported instanceof Uint8Array)) throw new Error('Expected Uint8Array');
          if (exported.length === 0) throw new Error('Expected non-empty export');
          db.close();
        }
      },
      {
        name: 'import() loads exported data',
        fn: async () => {
          const db1 = await createDatabase();
          db1.exec('CREATE TABLE test (value INTEGER)');
          db1.run('INSERT INTO test VALUES (99)');
          const exported = db1.export();

          const db2 = await createDatabase();
          db2.import(exported);
          const row = db2.get('SELECT value FROM test');
          if (row.value !== 99) throw new Error('Import failed');

          db1.close();
          db2.close();
        }
      },

      // Error handling tests
      {
        name: 'throws SqlSyntaxError on syntax error',
        fn: async () => {
          const db = await createDatabase();
          try {
            db.exec('INVALID SQL SYNTAX HERE');
            throw new Error('Should have thrown');
          } catch (e) {
            if (!(e instanceof SqlSyntaxError)) throw new Error('Expected SqlSyntaxError');
          }
          db.close();
        }
      },
      {
        name: 'throws SqlConstraintError on constraint violation',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT UNIQUE)');
          db.run('INSERT INTO test VALUES (1, "unique")');
          try {
            db.run('INSERT INTO test VALUES (2, "unique")');
            throw new Error('Should have thrown');
          } catch (e) {
            if (!(e instanceof SqlConstraintError)) throw new Error('Expected SqlConstraintError');
          }
          db.close();
        }
      },
      {
        name: 'throws SqlNotFoundError on missing table',
        fn: async () => {
          const db = await createDatabase();
          try {
            db.run('SELECT * FROM nonexistent_table');
            throw new Error('Should have thrown');
          } catch (e) {
            if (!(e instanceof SqlNotFoundError)) throw new Error('Expected SqlNotFoundError');
          }
          db.close();
        }
      },
      {
        name: 'throws TypeError on invalid parameter type',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER)');
          try {
            db.run('INSERT INTO test VALUES (?)', [{ invalid: 'object' }]);
            throw new Error('Should have thrown');
          } catch (e) {
            if (!(e instanceof TypeError)) throw new Error('Expected TypeError');
          }
          db.close();
        }
      },

      // Utility tests
      {
        name: 'getTables() returns table names',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE users (id INTEGER)');
          db.exec('CREATE TABLE products (id INTEGER)');
          const tables = db.getTables();
          if (!tables.includes('users')) throw new Error('Expected users table');
          if (!tables.includes('products')) throw new Error('Expected products table');
          db.close();
        }
      },
      {
        name: 'getTableInfo() returns column info',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT NOT NULL, age INTEGER)');
          const info = db.getTableInfo('test');
          if (info.length !== 3) throw new Error('Expected 3 columns');
          const idCol = info.find(c => c.name === 'id');
          if (!idCol.primaryKey) throw new Error('id should be primary key');
          db.close();
        }
      },
      {
        name: 'clone() creates independent copy',
        fn: async () => {
          const db1 = await createDatabase();
          db1.exec('CREATE TABLE test (value INTEGER)');
          db1.run('INSERT INTO test VALUES (42)');

          const db2 = await db1.clone();
          db2.run('INSERT INTO test VALUES (99)');

          if (db1.all('SELECT * FROM test').length !== 1) throw new Error('Original modified');
          if (db2.all('SELECT * FROM test').length !== 2) throw new Error('Clone incorrect');

          db1.close();
          db2.close();
        }
      },
      {
        name: 'clear() deletes all data but keeps schema',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (id INTEGER)');
          db.run('INSERT INTO test VALUES (1), (2), (3)');
          db.clear();

          if (db.all('SELECT * FROM test').length !== 0) throw new Error('Data not cleared');
          if (!db.getTables().includes('test')) throw new Error('Table should exist');
          db.close();
        }
      },
      {
        name: 'close() prevents further operations',
        fn: async () => {
          const db = await createDatabase();
          db.close();
          try {
            db.exec('CREATE TABLE test (id INTEGER)');
            throw new Error('Should have thrown');
          } catch (e) {
            if (!e.message.includes('closed')) throw new Error('Expected closed error');
          }
        }
      },

      // Prepared statement tests
      {
        name: 'prepare() creates reusable statement',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (value INTEGER)');
          const stmt = db.prepare('INSERT INTO test VALUES (?)');
          stmt.run([1]);
          stmt.run([2]);
          stmt.run([3]);
          stmt.finalize();

          if (db.all('SELECT * FROM test').length !== 3) throw new Error('Expected 3 rows');
          db.close();
        }
      },
      {
        name: 'insertMany() batch inserts rows',
        fn: async () => {
          const db = await createDatabase();
          db.exec('CREATE TABLE test (name TEXT, age INTEGER)');
          const rows = [
            { name: 'Alice', age: 30 },
            { name: 'Bob', age: 25 },
            { name: 'Charlie', age: 35 }
          ];
          const ids = db.insertMany('test', rows);
          if (ids.length !== 3) throw new Error('Expected 3 IDs');
          if (db.all('SELECT * FROM test').length !== 3) throw new Error('Expected 3 rows');
          db.close();
        }
      }
    ];

    // Test runner functions
    function logResult(name, status, error) {
      const output = document.getElementById('test-output');
      const className = status === 'PASS' ? 'test-pass' : 'test-fail';
      const errorMsg = error ? ` - ${error}` : '';
      const line = document.createElement('div');
      line.className = className;
      line.textContent = `[${status}] ${name}${errorMsg}`;
      output.appendChild(line);
      output.scrollTop = output.scrollHeight;
    }

    function logSummary(passed, failed) {
      const summary = document.getElementById('summary');
      const total = passed + failed;
      const className = failed === 0 ? 'test-pass' : 'test-fail';
      summary.innerHTML = `<span class="${className}">${passed}/${total} tests passed</span>`;
    }

    async function runAllTests() {
      clearResults();
      const output = document.getElementById('test-output');
      output.textContent = 'Running tests...\n\n';

      let passed = 0, failed = 0;

      for (const test of tests) {
        try {
          await test.fn();
          logResult(test.name, 'PASS');
          passed++;
        } catch (e) {
          logResult(test.name, 'FAIL', e.message);
          failed++;
        }
      }

      logSummary(passed, failed);
    }

    function clearResults() {
      document.getElementById('test-output').innerHTML = '';
      document.getElementById('summary').innerHTML = '';
    }

    // Interactive demo functions
    async function executeQuery() {
      const sql = document.getElementById('query-sql').value;
      const output = document.getElementById('query-output');

      try {
        const db = await initDemoDb();
        const statements = sql.trim().split(';').filter(s => s.trim());
        let result = '';

        for (const statement of statements) {
          const trimmed = statement.trim();
          if (!trimmed) continue;

          if (trimmed.toUpperCase().startsWith('SELECT')) {
            const rows = db.all(trimmed);
            result += `Query returned ${rows.length} rows:\n`;
            result += JSON.stringify(rows, null, 2) + '\n\n';
          } else {
            db.exec(trimmed);
            result += `‚úì Executed: ${trimmed.substring(0, 50)}...\n`;
          }
        }

        output.textContent = result || 'Query executed successfully';
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    function clearQuery() {
      document.getElementById('query-sql').value = '';
      document.getElementById('query-output').textContent = '';
      document.getElementById('query-output').className = 'output';
    }

    async function createTable() {
      const tableName = document.getElementById('table-name').value;
      const output = document.getElementById('table-output');

      try {
        const db = await initDemoDb();
        db.exec(`CREATE TABLE IF NOT EXISTS ${tableName} (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          price REAL,
          stock INTEGER DEFAULT 0
        )`);
        output.textContent = `‚úì Table "${tableName}" created successfully`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function insertProduct() {
      const tableName = document.getElementById('table-name').value;
      const output = document.getElementById('table-output');

      try {
        const db = await initDemoDb();
        const table = db.table(tableName);
        const products = [
          { name: 'Widget', price: 9.99, stock: 100 },
          { name: 'Gadget', price: 19.99, stock: 50 },
          { name: 'Doohickey', price: 14.99, stock: 75 }
        ];

        for (const product of products) {
          table.insert(product);
        }

        output.textContent = `‚úì Inserted 3 products into "${tableName}"`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function queryProducts() {
      const tableName = document.getElementById('table-name').value;
      const output = document.getElementById('table-output');

      try {
        const db = await initDemoDb();
        const table = db.table(tableName);
        const products = table.all();
        output.textContent = `Found ${products.length} products:\n\n${JSON.stringify(products, null, 2)}`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    function clearTableOutput() {
      document.getElementById('table-output').textContent = '';
      document.getElementById('table-output').className = 'output';
    }

    async function testTransactionCommit() {
      const output = document.getElementById('transaction-output');

      try {
        const db = await initDemoDb();
        db.exec('CREATE TABLE IF NOT EXISTS txn_test (id INTEGER PRIMARY KEY, value TEXT)');

        await db.transaction(() => {
          db.run('INSERT INTO txn_test (value) VALUES (?)', ['first']);
          db.run('INSERT INTO txn_test (value) VALUES (?)', ['second']);
        });

        const count = db.get('SELECT COUNT(*) as count FROM txn_test').count;
        output.textContent = `‚úì Transaction committed successfully\nTotal rows in txn_test: ${count}`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function testTransactionRollback() {
      const output = document.getElementById('transaction-output');

      try {
        const db = await initDemoDb();
        db.exec('CREATE TABLE IF NOT EXISTS txn_test (id INTEGER PRIMARY KEY, value TEXT)');

        const beforeCount = db.get('SELECT COUNT(*) as count FROM txn_test').count;

        try {
          await db.transaction(() => {
            db.run('INSERT INTO txn_test (value) VALUES (?)', ['will-rollback']);
            throw new Error('Intentional rollback');
          });
        } catch {}

        const afterCount = db.get('SELECT COUNT(*) as count FROM txn_test').count;

        if (beforeCount === afterCount) {
          output.textContent = `‚úì Transaction rolled back successfully\nRow count unchanged: ${afterCount}`;
          output.className = 'output success';
        } else {
          throw new Error('Rollback failed');
        }
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function demoQueueConcurrent() {
      const output = document.getElementById('queue-output');
      try {
        const db = await initDemoDb();

        // Create test table
        db.exec('CREATE TABLE IF NOT EXISTS queue_test (id INTEGER PRIMARY KEY, value TEXT, timestamp INTEGER)');
        db.exec('DELETE FROM queue_test');

        output.textContent = '‚è≥ Starting 5 concurrent transactions...\n';
        output.className = 'output';

        const startTime = Date.now();

        // Run 5 transactions concurrently - will be automatically queued
        const results = await Promise.all([
          db.transaction(async () => {
            db.run('INSERT INTO queue_test (value, timestamp) VALUES (?, ?)', ['Transaction 1', Date.now()]);
            return 'T1 complete';
          }),
          db.transaction(async () => {
            db.run('INSERT INTO queue_test (value, timestamp) VALUES (?, ?)', ['Transaction 2', Date.now()]);
            return 'T2 complete';
          }),
          db.transaction(async () => {
            db.run('INSERT INTO queue_test (value, timestamp) VALUES (?, ?)', ['Transaction 3', Date.now()]);
            return 'T3 complete';
          }),
          db.transaction(async () => {
            db.run('INSERT INTO queue_test (value, timestamp) VALUES (?, ?)', ['Transaction 4', Date.now()]);
            return 'T4 complete';
          }),
          db.transaction(async () => {
            db.run('INSERT INTO queue_test (value, timestamp) VALUES (?, ?)', ['Transaction 5', Date.now()]);
            return 'T5 complete';
          })
        ]);

        const elapsed = Date.now() - startTime;

        // Verify all transactions completed
        const count = db.get('SELECT COUNT(*) as cnt FROM queue_test');

        output.textContent = `‚úÖ Success!\n\n` +
          `Results: ${results.join(', ')}\n` +
          `Inserted: ${count.cnt} rows\n` +
          `Time: ${elapsed}ms\n\n` +
          `üí° All transactions queued automatically and executed serially!`;
        output.className = 'output success';

      } catch (error) {
        output.textContent = `‚ùå Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function demoQueueWithProgress() {
      const output = document.getElementById('queue-output');
      try {
        const db = await initDemoDb();

        db.exec('CREATE TABLE IF NOT EXISTS progress_test (id INTEGER PRIMARY KEY, step TEXT)');
        db.exec('DELETE FROM progress_test');

        let progress = [];

        // Helper to update display
        const updateDisplay = () => {
          output.textContent = progress.join('\n');
          output.className = 'output';
        };

        progress.push('‚è≥ Queueing 10 transactions...');
        updateDisplay();

        // Create 10 transactions with delays to show sequential execution
        const promises = Array.from({ length: 10 }, (_, i) =>
          db.transaction(async () => {
            progress.push(`  ‚ñ∂Ô∏è Transaction ${i + 1} executing...`);
            updateDisplay();

            // Simulate work
            await new Promise(resolve => setTimeout(resolve, 50));
            db.run('INSERT INTO progress_test (step) VALUES (?)', [`Step ${i + 1}`]);

            progress.push(`  ‚úÖ Transaction ${i + 1} complete`);
            updateDisplay();

            return i + 1;
          })
        );

        await Promise.all(promises);

        const count = db.get('SELECT COUNT(*) as cnt FROM progress_test');
        progress.push(`\n‚úÖ All ${count.cnt} transactions completed successfully!`);
        progress.push(`üí° Each transaction waited for the previous to finish.`);
        updateDisplay();
        output.className = 'output success';

      } catch (error) {
        output.textContent = `‚ùå Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function demoQueueNested() {
      const output = document.getElementById('queue-output');
      try {
        const db = await initDemoDb();

        db.exec('CREATE TABLE IF NOT EXISTS nested_test (id INTEGER PRIMARY KEY, type TEXT, value TEXT)');
        db.exec('DELETE FROM nested_test');

        output.textContent = '‚è≥ Running concurrent transactions with nesting...\n';
        output.className = 'output';

        // Run 3 concurrent transactions, each with nested transaction
        const results = await Promise.all([
          db.transaction(async () => {
            db.run('INSERT INTO nested_test (type, value) VALUES (?, ?)', ['outer', 'T1-outer']);

            // Nested transaction uses savepoint automatically
            await db.transaction(async () => {
              db.run('INSERT INTO nested_test (type, value) VALUES (?, ?)', ['inner', 'T1-inner']);
            });

            return 'T1 (outer + nested)';
          }),
          db.transaction(async () => {
            db.run('INSERT INTO nested_test (type, value) VALUES (?, ?)', ['outer', 'T2-outer']);

            await db.transaction(async () => {
              db.run('INSERT INTO nested_test (type, value) VALUES (?, ?)', ['inner', 'T2-inner']);
            });

            return 'T2 (outer + nested)';
          }),
          db.transaction(async () => {
            db.run('INSERT INTO nested_test (type, value) VALUES (?, ?)', ['outer', 'T3-outer']);

            await db.transaction(async () => {
              db.run('INSERT INTO nested_test (type, value) VALUES (?, ?)', ['inner', 'T3-inner']);
            });

            return 'T3 (outer + nested)';
          })
        ]);

        const rows = db.all('SELECT * FROM nested_test ORDER BY id');

        output.textContent = `‚úÖ Success!\n\n` +
          `Completed: ${results.join(', ')}\n` +
          `Total rows inserted: ${rows.length}\n\n` +
          `Breakdown:\n` +
          rows.map(r => `  ‚Ä¢ ${r.type}: ${r.value}`).join('\n') + '\n\n' +
          `üí° Concurrent transactions queued, nested ones used savepoints!`;
        output.className = 'output success';

      } catch (error) {
        output.textContent = `‚ùå Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function demoQueueStress() {
      const output = document.getElementById('queue-output');
      try {
        const db = await initDemoDb();

        db.exec('CREATE TABLE IF NOT EXISTS stress_test (id INTEGER PRIMARY KEY, txn_num INTEGER)');
        db.exec('DELETE FROM stress_test');

        output.textContent = '‚è≥ Starting stress test with 100 concurrent transactions...\n';
        output.className = 'output';

        const startTime = Date.now();

        // Create 100 concurrent transactions
        const promises = Array.from({ length: 100 }, (_, i) =>
          db.transaction(async () => {
            db.run('INSERT INTO stress_test (txn_num) VALUES (?)', [i]);
            return i;
          })
        );

        const results = await Promise.all(promises);
        const elapsed = Date.now() - startTime;

        const count = db.get('SELECT COUNT(*) as cnt FROM stress_test');
        const min = db.get('SELECT MIN(txn_num) as min FROM stress_test');
        const max = db.get('SELECT MAX(txn_num) as max FROM stress_test');

        output.textContent = `‚úÖ Stress Test Complete!\n\n` +
          `Transactions: 100\n` +
          `Successful: ${results.length}\n` +
          `Rows inserted: ${count.cnt}\n` +
          `Range: ${min.min} to ${max.max}\n` +
          `Total time: ${elapsed}ms\n` +
          `Avg per transaction: ${(elapsed / 100).toFixed(2)}ms\n\n` +
          `üí° Transaction queue handled high concurrency without errors!`;
        output.className = 'output success';

      } catch (error) {
        output.textContent = `‚ùå Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function exportDatabase() {
      const output = document.getElementById('export-output');

      try {
        const db = await initDemoDb();
        exportedData = db.export();
        output.textContent = `‚úì Database exported\nSize: ${exportedData.length} bytes`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function importDatabase() {
      const output = document.getElementById('export-output');

      try {
        if (!exportedData) {
          throw new Error('No exported data. Export first.');
        }

        const db = await initDemoDb();
        db.import(exportedData);

        output.textContent = `‚úì Database imported successfully\nSize: ${exportedData.length} bytes`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function downloadDatabase() {
      const output = document.getElementById('export-output');

      try {
        const db = await initDemoDb();
        const data = db.export();

        const blob = new Blob([data], { type: 'application/x-sqlite3' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'demo-database.sqlite';
        a.click();
        URL.revokeObjectURL(url);

        output.textContent = `‚úì Database downloaded as demo-database.sqlite`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function runMigration() {
      const output = document.getElementById('migration-output');

      try {
        const db = await initDemoDb();
        const migrations = [
          {
            version: 1,
            up: 'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)',
            down: 'DROP TABLE users'
          }
        ];

        const applied = await db.migrate(migrations);
        const version = db.getMigrationVersion();

        output.textContent = `‚úì Migration v1 applied\nApplied: ${applied}\nCurrent version: ${version}`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function runMigration2() {
      const output = document.getElementById('migration-output');

      try {
        const db = await initDemoDb();
        const migrations = [
          {
            version: 1,
            up: 'CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)',
            down: 'DROP TABLE users'
          },
          {
            version: 2,
            up: 'CREATE TABLE orders (id INTEGER PRIMARY KEY, user_id INTEGER, total REAL)',
            down: 'DROP TABLE orders'
          }
        ];

        const applied = await db.migrate(migrations);
        const version = db.getMigrationVersion();

        output.textContent = `‚úì Migration v2 applied\nApplied: ${applied}\nCurrent version: ${version}`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function checkMigrationVersion() {
      const output = document.getElementById('migration-output');

      try {
        const db = await initDemoDb();
        const version = db.getMigrationVersion();
        const tables = db.getTables();

        output.textContent = `Current migration version: ${version}\nTables: ${tables.join(', ')}`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }

    async function rollbackMigration() {
      const output = document.getElementById('migration-output');

      try {
        const db = await initDemoDb();
        const migrations = [
          {
            version: 1,
            up: 'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)',
            down: 'DROP TABLE users'
          },
          {
            version: 2,
            up: 'CREATE TABLE orders (id INTEGER PRIMARY KEY, user_id INTEGER, total REAL)',
            down: 'DROP TABLE orders'
          }
        ];

        const rolledBack = await db.rollback(1, migrations);
        const version = db.getMigrationVersion();

        output.textContent = `‚úì Rolled back to v1\nRolled back: ${rolledBack}\nCurrent version: ${version}`;
        output.className = 'output success';
      } catch (error) {
        output.textContent = `Error: ${error.message}`;
        output.className = 'output error';
      }
    }
  </script>
</body>
</html>
